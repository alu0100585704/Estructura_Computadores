//$2 registro borrador

li $8,0 //0 indica que se ha soltado cualquier boton o no se ha pulsado.
li $1,1 //para incrementar, decrementar y comparar con boton push_up
li $3,2 //para comparar con boton push_down
li $4,4 // para comparar con boton reset
li $14,18 //valor maximo de volumen
li $15,0  /valor inicial de volumen

inicio: sub $8,$1,$2
jz pulsador_apretado
jmp inicio

//La rutina de tiempo está pensada para una velocidad de 25MHz, o sea, un ciclo de 40 nanosegundos
//Con $11=4 equivale a 1 segundo
//con $11=2 equivale a medio segundo.
//habría que incrementar o decrementar el valor del registro  $11 si cambia la frecuencia de funcionamiento


pulsador_apretado:  jal botones
		    li $11,96 //para 1 segundo. 96 * 260865 =25.043.040 instrucciones  o ciclos
bucle0:		li $10,255   
bucle1:     li $9,255 
bucle2:		sub $8,$1,$2 //bucle2: 4 instrucciones del bucle por 255 * 255 = 260100 + 765(3 instrucciones bucle 1*255) = 260865 instrucciones o ciclos * 40 nanosegundos = 0.0104346 segundo (10 milisegundos)
			jnz inicio
			sub $9,$1,$9
			jnz bucle2
			sub $10,$1,$10
			jnz bucle1
			sub $11,$1,$11
			jnz bucle0
			jal botones
			li $11,48 //contador para medio segundo
			jmp bucle0


botones:
		inr PE1,$5 //en $5 valor del puerto 1, este puerto estará tendrá sus tres bits menos significativos conectados a los pulsadores push_up push_down y reset
		sub $5,$1,$2 //comparo con push_up
		jz push_up
		sub $5,$3,$2 //comparo con push_down
		jz push_down
		sub $5,$4,$2
		jz reset
salir_botones:		jr

push_up: sub $15,$14,$2
		jz salir_botones
		add $15,$1,$15
		jmp leds //activa led correspondientes
	
push_down: add $15,$14,$2
		sub $2,$14,$2
		jz salir_botones //regreso porque ya estoy al minimo de volumen
		sub $15,$1,$15
		jmp leds //activa led correspondientes

reset:  
	  li $15,0
	  jmp leds
leds:
		li $5,0
		li $6,0
		li $7,0
		li $13,0
		sub $15,$13,$2
		jz out_led //led con volumen cero, o sea, todos apagados.

		li $5,1
		li $6,0
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 1

		li $5,2
		li $6,0
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 2

		li $5,4
		li $6,0
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 3

		li $5,8
		li $6,0
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 4

		li $5,16
		li $6,0
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 5

		li $5,32
		li $6,0
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 6


		li $5,64
		li $6,0
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 7


		li $5,128
		li $6,0
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 8


		li $5,0
		li $6,1
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 9


		li $5,0
		li $6,2
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 10


		li $5,0
		li $6,4
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 11


		li $5,0
		li $6,8
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 12


		li $5,0
		li $6,16
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 13


		li $5,0
		li $6,32
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 14


		li $5,0
		li $6,64
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 15


		li $5,0
		li $6,128
		li $7,0		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 16


		li $5,0
		li $6,0
		li $7,1		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 17


		li $5,0
		li $6,0
		li $7,2		
		add $13,$1,$13 
		sub $15,$13,$2
		jz out_led  //led volumen 18

jmp salir_botones




out_led: //enciendo o apago leds según configuracion

out PS1,$5
out PS2,$6
out PS3,$7
jmp salir_botones


		
interrupcion: 

//tengo que salvaguardar el flag z, puesto que la interrupcion pudo haberset generado entre la operacion de comparacion y la de salto, o sea, puede que entre un sub $algo, $otro,$resultado, se haya
//activado el flag z y si se generó la interrupción en ese justo momento, y el codigo de la interrupcion en algún momento ejecuta operaciones que me establecen el flag z a cero, despúes al regresar y
//salir de la interrupción, la continuación del flujo normal del programa podría verse afectada.

push $1
push $2
li $1,1
jz z_igual_1  // si salta es porque z estaba en 1.


li $2,0 

jmp continua_interrupcion

z_igual_1:

li $2,1

jmp continua_interrupcion


continua_interrupcion:

sub $8,$1,$8
jz poner a cero
li $8,1
jmp salir_interrupcion

poner_a_cero:
li $8,0
jmp salir_interrupcion

salir_interrupcion: 
debug $8
add $0,$0,$0
debug $15
sub $1,$2,$1 //con esto pongo el flag z como estaba, ya que solo las operaciones alu lo modifican.
pop $2 //restauro los registros
pop $1
iret

*/
//opcodes definicos:

//Bits [15:10] 100000xxxxxxxxxx  jal, PC=xxxxxxxxxx y PC+1 a la pila.
//Bits [15:10] 100001??????????  jr, salta donde diga valor de pila
//Bits [15:10] 100010??????xxxx  pop pila a registro indicado por xxxx
//Bits [15:10] 100011??????????  iret, salta donde diga valor de pila y restaura flag int_en_curso, indicando que ya se ha terminado de atender la interrupción
//Bits [15:12] 1???aaaabbbbcccc Operación de alu, donde ? identifica el tipo de operacion, a operando 1(numero de registro) y b operando 2(numero de registro), resultado en c(numero de registro destino)
//Bits [15:12] 0100xxxxxxxxzzzz Operación de carga inmediata en registro, x valor inmediato de 8 bits y z(numero de registro donde almacenar el resultado)

//Bits [15:12] 0101xxxx0000zzzz Opercion IN puerto como registro(x),registro destino(z)
//Bits [15:12] 0110xxxxzzzzzzzz Opercion OUT puerto como registro(x),valor inmediato(z)
//Bits [15:12] 0111xxxxzzzz0000 Opercion OUT puerto como registro(x),registro(z)

//Bits [15:12] 0010xxxx???????? Opercion debug(para debug), puestra el valor del registro xxxx, o sea, el valor rd1
//Bits [15:12] 0011xxxx???????? push pila valor del registro indicado en xxxx
//Bits [15:12] 0001????xxxxzzzz Operación IN puerto de solo lectura. xxxx(numero de puerto) zzzz(registro destino) inr

//Bits [15:10] 000001xxxxxxxxxx salto incondicional x direccion del banco de memoria
//Bits [15:10] 000010xxxxxxxxxx jz salto condicional si z=1. x direccion del salto de memoria
//Bits [15:10] 000011xxxxxxxxxx jnz salto condicional si z=0  x direccion de la memoria.

 
 
//  libre_pero_no_recomendada= 6'b000000; //libre pero a no ser que termine bien el programa, como el fichero de instrucciones esta lleno de esta combinación, podrían ejecutarse la instruccion utilizada
//con este teórico opcode repetidas veces.

